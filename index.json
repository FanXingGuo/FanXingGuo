[{"categories":["编程学习"],"content":"由const关键字修饰的引用，称之为对常量的引用，简称为常量引用。 与普通引用不同的是，对常量引用不能修改它所绑定的对象的——对引用的操作作出了限定。 ","date":"2022-09-01","objectID":"/cppconst/:0:0","tags":["C++","const","const 修饰符"],"title":"const、const_cast、const 成员函数","uri":"/cppconst/"},{"categories":["编程学习"],"content":"const ","date":"2022-09-01","objectID":"/cppconst/:1:0","tags":["C++","const","const 修饰符"],"title":"const、const_cast、const 成员函数","uri":"/cppconst/"},{"categories":["编程学习"],"content":"const引用 由const关键字修饰的引用，称之为对常量的引用，简称为常量引用。 与普通引用不同的是，对常量引用不能修改它所绑定的对象的——对引用的操作作出了限定。 const int ci=1024; // 值不能被修改 const int \u0026r1=ci; // r1 不能被修改 const 可以绑定一个非常量对象 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cstdio.h\u003e#include \"../lib/Student.h\"using namespace std; int main(int argc,char ** argv) { int i=9; int \u0026r=i; const int \u0026ri=i; // int \u0026rc=5; 引用不可绑定到常量 const int \u0026rc=5; return 0; } const 提高了函数的兼容性 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cstdio.h\u003e#include \"../lib/Student.h\"using namespace std; void func(const Object \u0026 obj){} //这里的类型，可以是 const Object obj，也可以是 Object obj; int main(int argc,char ** argv) { Object obj; func(obj); return 0; } ","date":"2022-09-01","objectID":"/cppconst/:1:1","tags":["C++","const","const 修饰符"],"title":"const、const_cast、const 成员函数","uri":"/cppconst/"},{"categories":["编程学习"],"content":"const 成员函数 当成员函数不会更改对象的任何成员变量时，可以将成员函数声明为const。 const修饰的对象，只能调用const修饰的进行成员函数。 非const修饰的对象，既能调用非const修饰的成员函数，又能调用const修饰的成员函数 头文件 // // Created by 范兴国 on 2022/7/12. // #ifndef STLLEN_STUDENT_H #define STLLEN_STUDENT_H #include \u003cstring\u003eusing namespace std; class Object{ private: int num; public: int getNum()const; // const 修饰成员函数 void setNum(int num); Object(int num); Object(); ~Object(); }; #endif //STLLEN_STUDENT_H // // Created by 范兴国 on 2022/7/12. // #include \"Student.h\"#include \u003ciostream\u003e#include \u003cstring.h\u003e using namespace std; Object::Object(int num):num(num) {} void Object::setNum(int num) { this-\u003enum=num; } int Object::getNum()const { return num; } Object::Object() { cout\u003c\u003c\"Object()\"\u003c\u003cendl; } Object::~Object() { cout\u003c\u003c\"~Object()\"\u003c\u003cendl; } main文件 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cstdio.h\u003e#include \"../lib/Student.h\"using namespace std; void func(const Object \u0026 obj){} int main(int argc,char ** argv) { Object obj(0); // const Object obj(0); 亦可调用getNum() cout\u003c\u003cobj.getNum()\u003c\u003cendl; return 0; } ","date":"2022-09-01","objectID":"/cppconst/:2:0","tags":["C++","const","const 修饰符"],"title":"const、const_cast、const 成员函数","uri":"/cppconst/"},{"categories":["编程学习"],"content":"const_cast 把常量对象转换非常量对象，一般成为“去掉const性质”。一旦去掉const性质，编译器不阻止写操作。 如果对象本身不是一个常量，使用强制类型转换获得写权限是合法行为。如果对象是一个常量，使用const_cast执行写操作会产生未定义的后果。 使用 const char *pt; char *p=const_cast\u003cchar *\u003e(pc); char \u0026r=const_cast\u003cchar \u0026\u003e(*pc); #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cstdio.h\u003e#include \"../lib/Student.h\"using namespace std; int main(int argc,char ** argv) { char c='z'; // 这里z本身是一个 非 常量，不能写:const char c='z'; const char *pc=\u0026c; // char *p=(char*)pc; C++推荐下面写法 char *p=const_cast\u003cchar*\u003e(pc); char \u0026rc=const_cast\u003cchar\u0026\u003e(*pc); return 0; } ","date":"2022-09-01","objectID":"/cppconst/:3:0","tags":["C++","const","const 修饰符"],"title":"const、const_cast、const 成员函数","uri":"/cppconst/"},{"categories":["编程学习"],"content":"引用是为某个对象起另外一个名字。引用并非新对象，而是绑定现有对象。 引用只能绑定到相同类型上。 使用引用的目的，在传递函数参数时，避免调用拷贝构造函数，提高程序执行效率 ","date":"2022-09-01","objectID":"/cppref/:0:0","tags":["C++","引用","友元函数","拷贝构造函数"],"title":"C++ 引用、友元函数、拷贝构造函数","uri":"/cppref/"},{"categories":["编程学习"],"content":"引用 引用是为某个对象起另外一个名字。引用并非新对象，而是绑定现有对象。 引用只能绑定到相同类型上。 使用引用的目的，在传递函数参数时，避免调用拷贝构造函数，提高程序执行效率 #include \u003ciostream\u003eusing namespace std; int main(int argc,char ** argv) { int a=0; int \u0026 r=a; // 引用类型 \u0026 引用名 = 特定的对象; r++; cout\u003c\u003ca\u003c\u003cendl; // 输出：1 return 0; } #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cstdio.h\u003e#include \"../lib/Student.h\"using namespace std; void func(Object obj){// 值传递，这里调用了拷贝构造函数 cout\u003c\u003cobj.getNum()\u003c\u003cendl; } void func0(Object \u0026obj){ // 这里使用的是引用，没有调用拷贝构造函数 cout\u003c\u003cobj.getNum()\u003c\u003cendl; } int main(int argc,char ** argv) { Object obj(7); func(obj); func0(obj); return 0; } //输出： ///Object::Object(const Object \u0026obj) //7 //7 ","date":"2022-09-01","objectID":"/cppref/:1:0","tags":["C++","引用","友元函数","拷贝构造函数"],"title":"C++ 引用、友元函数、拷贝构造函数","uri":"/cppref/"},{"categories":["编程学习"],"content":"友元函数 头文件声明 // // Created by 范兴国 on 2022/7/12. // #ifndef STLLEN_STUDENT_H #define STLLEN_STUDENT_H #include \u003cstring\u003eusing namespace std; class Object{ friend void func(Object \u0026 obj); //声明友元函数 private: int num; public: Object(int num); }; #endif //STLLEN_STUDENT_H // // Created by 范兴国 on 2022/7/12. // #include \"Student.h\"#include \u003ciostream\u003e#include \u003cstring.h\u003e using namespace std; Object::Object(int num) :num(num){} 主文件 #include \u003ciostream\u003e#include \"../lib/Student.h\"using namespace std; void func(Object \u0026 obj); void func(Object \u0026 obj){ obj.num=9; cout\u003c\u003cobj.num\u003c\u003cendl; //友元函数可以访问私有变量 } int main(int argc,char ** argv) { Object obj(0); func(obj); return 0; } ","date":"2022-09-01","objectID":"/cppref/:2:0","tags":["C++","引用","友元函数","拷贝构造函数"],"title":"C++ 引用、友元函数、拷贝构造函数","uri":"/cppref/"},{"categories":["编程学习"],"content":"拷贝构造函数 拷贝构造函数是一种特殊的构造函数，其唯一的形参必须是构造对象的引用。 编译器会自动生成拷贝构造函数，会把参数所有非静态成员传递给对象。 ","date":"2022-09-01","objectID":"/cppref/:3:0","tags":["C++","引用","友元函数","拷贝构造函数"],"title":"C++ 引用、友元函数、拷贝构造函数","uri":"/cppref/"},{"categories":["编程学习"],"content":"被自动调用的情况： 对象作为参数，以值传递方式传入函数体。 对象作为函数返回值，以值传递方式从函数返回。 对象用于给另一对象初始化。 ","date":"2022-09-01","objectID":"/cppref/:3:1","tags":["C++","引用","友元函数","拷贝构造函数"],"title":"C++ 引用、友元函数、拷贝构造函数","uri":"/cppref/"},{"categories":["编程学习"],"content":"头文件 // // Created by 范兴国 on 2022/7/12. // #ifndef STLLEN_STUDENT_H #define STLLEN_STUDENT_H #include \u003cstring\u003eusing namespace std; class Object{ private: int num; public: int getNum(); void setNum(int num); Object(int num); Object(const Object \u0026 obj); // 拷贝构造函数声明 }; #endif //STLLEN_STUDENT_H // // Created by 范兴国 on 2022/7/12. // #include \"Student.h\"#include \u003ciostream\u003e#include \u003cstring.h\u003e using namespace std; Object::Object(int num) :num(num){} int Object::getNum() { return num; } void Object::setNum(int num) { this-\u003enum=num; } Object::Object(const Object \u0026obj) { cout\u003c\u003c\"Object::Object(const Object \u0026obj)\"\u003c\u003cendl; num=obj.num; // 加上这一句，可以使参数传递，打印结果 0 变 7 } 主文件 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cstdio.h\u003e#include \"../lib/Student.h\"using namespace std; void func(Object obj){// 这里调用了拷贝构造函数 cout\u003c\u003cobj.getNum()\u003c\u003cendl; } int main(int argc,char ** argv) { Object obj(7); func(obj); return 0; } //输出： // Object::Object(const Object \u0026obj) // 0 ","date":"2022-09-01","objectID":"/cppref/:3:2","tags":["C++","引用","友元函数","拷贝构造函数"],"title":"C++ 引用、友元函数、拷贝构造函数","uri":"/cppref/"},{"categories":["编程学习"],"content":"面向对象编程：封装、继承、多态 ","date":"2022-09-01","objectID":"/cppfz/:0:0","tags":["C++","封装","单例模式","静态成员"],"title":"C++面向对象编程：封装、单例模式、静态成员","uri":"/cppfz/"},{"categories":["编程学习"],"content":"面向对象编程：封装、单例模式、静态成员 面向对象编程：封装、继承、多态 ","date":"2022-09-01","objectID":"/cppfz/:1:0","tags":["C++","封装","单例模式","静态成员"],"title":"C++面向对象编程：封装、单例模式、静态成员","uri":"/cppfz/"},{"categories":["编程学习"],"content":"封装 封装，指的是信息隐藏。把使用者不需要知道的数据、流程隐藏起来，只留下操作的接口。 访问控制：Public、Private strncpy(stu.name,\"Tom\",20); //假如有20w 行，如果修改属性name的名称为stuName，要修改20w行 // 使用封装 main.cpp #include \u003ciostream\u003e#include \u003cstring\u003e#include \"../lib/Student.h\"using namespace std; int main(int argc,char ** argv) { Student stu; stu.setName(\"Tom\"); // 这里把实现细节隐藏,在方法内部修改变量名称 stu.introudce(); return 0; } // Student.h // // Created by 范兴国 on 2022/7/12. // #ifndef STLLEN_STUDENT_H #define STLLEN_STUDENT_H #include \u003cstring\u003eusing namespace std; class Student{ char name[20]; public: void setName(const char * name); void introudce(); char * getName(); }; #endif //STLLEN_STUDENT_H // Student.cpp // // Created by 范兴国 on 2022/7/12. // #include \"Student.h\"#include \u003ciostream\u003e#include \u003cstring.h\u003e using namespace std; void Student::setName(const char *name) { strncpy(this-\u003ename,name,20); } char * Student::getName() { return this-\u003ename; } void Student::introudce() { cout\u003c\u003c\"I am \"\u003c\u003cname\u003c\u003cendl; } ","date":"2022-09-01","objectID":"/cppfz/:1:1","tags":["C++","封装","单例模式","静态成员"],"title":"C++面向对象编程：封装、单例模式、静态成员","uri":"/cppfz/"},{"categories":["编程学习"],"content":"静态成员 属于整个类的属性或者行为，而不是属于某个类的 静态成员类型需要定义。 头文件定义 // Student.h // Created by 范兴国 on 2022/7/12. // #ifndef STLLEN_STUDENT_H #define STLLEN_STUDENT_H #include \u003cstring\u003eusing namespace std; class Bank{ public: static double rate; static double calc(double money); //计算利率 }; #endif //STLLEN_STUDENT_H // Student.cpp // Created by 范兴国 on 2022/7/12. // #include \"Student.h\"#include \u003ciostream\u003e#include \u003cstring.h\u003e using namespace std; double Bank::rate=0.05; double Bank::calc(double money) { return money*rate; } 主文件定义 // main.cpp // Created by 范兴国 on 2022/7/12. // #include \"Student.h\"#include \u003ciostream\u003e#include \u003cstring.h\u003e using namespace std; double Bank::rate=0.05; double Bank::calc(double money) { return money*rate; } ","date":"2022-09-01","objectID":"/cppfz/:1:2","tags":["C++","封装","单例模式","静态成员"],"title":"C++面向对象编程：封装、单例模式、静态成员","uri":"/cppfz/"},{"categories":["编程学习"],"content":"单例模式 保证系统生成的类唯一。 头文件定义 // Student.h // Created by 范兴国 on 2022/7/12. // #ifndef STLLEN_STUDENT_H #define STLLEN_STUDENT_H #include \u003cstring\u003eusing namespace std; class SingleOne{ private: SingleOne(); // 1、私有化构造函数 static SingleOne * instance; //2、定义单例对象的指针 public: static SingleOne* getInstance(); // 3、创建一个方法，返回对象 }; #endif //STLLEN_STUDENT_H // Student.cpp // Created by 范兴国 on 2022/7/12. // #include \"Student.h\"#include \u003ciostream\u003e#include \u003cstring.h\u003e using namespace std; SingleOne* SingleOne::instance=0; SingleOne::SingleOne() {} SingleOne * SingleOne::getInstance() { if(instance==0){ instance=new SingleOne();// 私有成员 类内部可以调用 } return instance; } 主函数 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cstdio.h\u003e#include \"../lib/Student.h\"using namespace std; int main(int argc,char ** argv) { SingleOne * instance=SingleOne::getInstance(); printf(\"instance: %p\",instance); SingleOne * instance1=SingleOne::getInstance(); printf(\"instance: %p\",instance1); SingleOne * instance2=SingleOne::getInstance(); printf(\"instance: %p\",instance2); return 0; } ","date":"2022-09-01","objectID":"/cppfz/:1:3","tags":["C++","封装","单例模式","静态成员"],"title":"C++面向对象编程：封装、单例模式、静态成员","uri":"/cppfz/"},{"categories":["编程学习"],"content":"介绍 C++语言中的构造函数更多用法、空间的申请与释放：new deldte。this指针的使用 ","date":"2022-07-18","objectID":"/constructionnewdeletethis/:0:0","tags":["C++","构造函数","new","delete","this","空间申请","空间释放"],"title":"C++ 构造函数、new deldte、this指针","uri":"/constructionnewdeletethis/"},{"categories":["编程学习"],"content":"构造函数 用于初始化对象成员属性 构造函数函数名，必须与类名一致 构造函数没有返回值 同一个类，可以有多个参数列表不同的构造函数 当且仅当类没有声明构造函数是，编译器会自动声明一个无参无内容构造函数 ","date":"2022-07-18","objectID":"/constructionnewdeletethis/:1:0","tags":["C++","构造函数","new","delete","this","空间申请","空间释放"],"title":"C++ 构造函数、new deldte、this指针","uri":"/constructionnewdeletethis/"},{"categories":["编程学习"],"content":"不同参数列表构造函数 // Student.h // Created by 范兴国 on 2022/7/12. // #ifndef STLLEN_STUDENT_H #define STLLEN_STUDENT_H #include \u003cstring\u003eusing namespace std; class Student{ public: char name[20]; double score; void introduce(); //Student(); 如果定义其他构造函数，此时默认构造函数不会初始化 Student(const char * name); Student(const char * name,double score); ~Student(); }; #endif //STLLEN_STUDENT_H // Student.cpp // Created by 范兴国 on 2022/7/12. // #include \"Student.h\"#include \u003ciostream\u003e#include \u003cstring.h\u003e using namespace std; void Student::introduce() { cout\u003c\u003c\"name:\"\u003c\u003cname\u003c\u003cendl; cout\u003c\u003c\"score:\"\u003c\u003cscore\u003c\u003cendl; } Student::Student(const char *name) { strncpy(this-\u003ename,name,20); } Student::Student(const char *name, double score) { strncpy(this-\u003ename,name,20); this-\u003escore=score; } Student::~Student() { cout\u003c\u003c\"Student::~Student()\"\u003c\u003cendl; } // main.cpp #include \u003ciostream\u003e#include \u003cstring.h\u003e#include \"../lib/Student.h\"using namespace std; int main(int argc,char ** argv) { Student stu(\"Tom\"); stu.introduce(); Student stu2(\"Petter\",88); stu2.introduce(); return 0; } /*输出： name:Tom score:6.95313e-310 name:Petter score:88 Student::~Student() Student::~Student() */ ","date":"2022-07-18","objectID":"/constructionnewdeletethis/:1:1","tags":["C++","构造函数","new","delete","this","空间申请","空间释放"],"title":"C++ 构造函数、new deldte、this指针","uri":"/constructionnewdeletethis/"},{"categories":["编程学习"],"content":"构造函数列表初始化 只支持参数通过赋值运算符赋值给成员。 初始化成员的顺序必须与类成员顺序一致。 // Student.h // Created by 范兴国 on 2022/7/12. // #ifndef STLLEN_STUDENT_H #define STLLEN_STUDENT_H #include \u003cstring\u003eusing namespace std; class Student{ public: char name[20]; double score; int age; //添加age void introduce(); Student(const char * name); Student(const char * name,double score,int age); // 添加age ~Student(); }; #endif //STLLEN_STUDENT_H // Student.cpp // Created by 范兴国 on 2022/7/12. // #include \"Student.h\"#include \u003ciostream\u003e#include \u003cstring.h\u003e using namespace std; void Student::introduce() { cout\u003c\u003c\"name:\"\u003c\u003cname\u003c\u003cendl; cout\u003c\u003c\"score:\"\u003c\u003cscore\u003c\u003cendl; cout\u003c\u003c\"age:\"\u003c\u003cage\u003c\u003cendl; } Student::Student(const char *name) { strncpy(this-\u003ename,name,20); } Student::Student(const char *name, double score,int age) :score(score),age(age){ strncpy(this-\u003ename,name,20); // name 不能直接赋值，因此不能列表初始化 } Student::~Student() { cout\u003c\u003c\"Student::~Student()\"\u003c\u003cendl; } // main.cpp #include \u003ciostream\u003e#include \u003cstring.h\u003e#include \"../lib/Student.h\"using namespace std; int main(int argc,char ** argv) { Student stu2(\"Petter\",88,24); stu2.introduce(); return 0; } /*输出： name:Petter score:88 age:24 Student::~Student() */ ","date":"2022-07-18","objectID":"/constructionnewdeletethis/:1:2","tags":["C++","构造函数","new","delete","this","空间申请","空间释放"],"title":"C++ 构造函数、new deldte、this指针","uri":"/constructionnewdeletethis/"},{"categories":["编程学习"],"content":"构造函数隐式调用 当构造函数只有一个参数时候，就可能出现构造函数隐式调用。 在构造函数声明前加上explicit关键字可以关闭构造函数隐式调用功能。 // main.cpp #include \u003ciostream\u003e#include \u003cstring.h\u003e#include \"../lib/Student.h\"using namespace std; int main(int argc,char ** argv) { Student tom=\"Tom\";//等价于：Student tom(\"Tom\"); tom.introduce(); return 0; } /*输出： name:Tom score:0 age:-287104112 Student::~Student() */ 关闭隐式调用 // // Created by 范兴国 on 2022/7/12. // #ifndef STLLEN_STUDENT_H #define STLLEN_STUDENT_H #include \u003cstring\u003eusing namespace std; class Student{ public: char name[20]; double score; int age; void introduce(); explicit Student(const char * name); // 关闭隐式调用 Student(const char * name,double score,int age); ~Student(); }; #endif //STLLEN_STUDENT_H ","date":"2022-07-18","objectID":"/constructionnewdeletethis/:1:3","tags":["C++","构造函数","new","delete","this","空间申请","空间释放"],"title":"C++ 构造函数、new deldte、this指针","uri":"/constructionnewdeletethis/"},{"categories":["编程学习"],"content":"new和delete C++两个关键字，用于向堆申请或释放空间，期间会调用构造/析构函数。 #include \u003ciostream\u003e#include \u003cstring.h\u003e#include \"../lib/Student.h\"using namespace std; int main(int argc,char ** argv) { // 创建和销毁单个对象 Student *student=new Student(); delete student; //创建和销毁多个对象 Student *students=new Student[5];// 此时会调用无参构造函数 delete []students; return 0; } ","date":"2022-07-18","objectID":"/constructionnewdeletethis/:2:0","tags":["C++","构造函数","new","delete","this","空间申请","空间释放"],"title":"C++ 构造函数、new deldte、this指针","uri":"/constructionnewdeletethis/"},{"categories":["编程学习"],"content":"this指针 在对象调用成员函数时，会额外将本身地址传递给成员函数。在函数体内部，可以通过this指针，获取到编译器隐式传入当前对象的地址，并访问对象的成员。 Student::Student(const char *name, double score,int age) :score(score),age(age){ // 使用this 区分 类成员变量和参数 strncpy(this-\u003ename,name,20); } ","date":"2022-07-18","objectID":"/constructionnewdeletethis/:3:0","tags":["C++","构造函数","new","delete","this","空间申请","空间释放"],"title":"C++ 构造函数、new deldte、this指针","uri":"/constructionnewdeletethis/"},{"categories":["编程学习"],"content":"了解C++类的声明、定义，对象 构造函数和析构函数 ","date":"2022-07-16","objectID":"/cppcalss/:0:0","tags":["C++","类","对象","构造函数","析构函数"],"title":"C++ 类 和对象 构造函数、析构函数","uri":"/cppcalss/"},{"categories":["编程学习"],"content":"类的声明 写在头文件中 // Student.h // // Created by 范兴国 on 2022/7/12. // #ifndef STLLEN_STUDENT_H #define STLLEN_STUDENT_H #include \u003cstring\u003e using namespace std; class Student{ private: int id; string name; public: Student(const string \u0026 name,int id); Student(); int getId()const; void Introduce()const; // 成员函数声明 }; #endif //STLLEN_STUDENT_H ","date":"2022-07-16","objectID":"/cppcalss/:0:1","tags":["C++","类","对象","构造函数","析构函数"],"title":"C++ 类 和对象 构造函数、析构函数","uri":"/cppcalss/"},{"categories":["编程学习"],"content":"类的定义 // Student.cpp // Created by 范兴国 on 2022/7/12. // #include \"Student.h\"#include \u003ciostream\u003e using namespace std; Student::Student() { cout\u003c\u003c\"Student::Student()\"\u003c\u003cendl; } Student::Student(const string \u0026name, int id):name(name),id(id){} int Student::getId() const { return id; } void Student::Introduce() const { // 成员函数定义 cout\u003c\u003cid\u003c\u003c\":\"\u003c\u003cname\u003c\u003cendl; } 类成员函数中可以自由访问类的成员属性和成员函数 类成员函数定义一般写在头文件对应的.cpp文件中 验证类定义语法正确 g++ -c Student.cpp -o Student.o -g -Wall ","date":"2022-07-16","objectID":"/cppcalss/:0:2","tags":["C++","类","对象","构造函数","析构函数"],"title":"C++ 类 和对象 构造函数、析构函数","uri":"/cppcalss/"},{"categories":["编程学习"],"content":"C++ 对象 ","date":"2022-07-16","objectID":"/cppcalss/:1:0","tags":["C++","类","对象","构造函数","析构函数"],"title":"C++ 类 和对象 构造函数、析构函数","uri":"/cppcalss/"},{"categories":["编程学习"],"content":"构造函数、析构函数 由于对象会在内存中占用一段空间，所以会有生命周期，也就是会有内存空间的申请和释放。 构造函数是对象申请内存空间之后自动调用的函数，析构函数是对象空间被销毁前自动调用的函数。 构造函数声明 构造函数没有返回值，构造函数函数名要有类名一致。可以有参数列表 // 参考 C++ 类 类的定义代码 // 构造函数定义在类的外部 Student::Student() { cout\u003c\u003c\"Student::Student()\"\u003c\u003cendl; } 创建对象 #include \u003ciostream\u003e#include \"Student.h\"using namespace std; int main(int argc,char ** argv) { Student stu; // 输出：Student::Student() return 0; } 析构函数 析构函数函数名：~+函数名 没有返回值，没有参数列表 // 代码，声明略 Student::~Student() { cout\u003c\u003c\"Student::~Student()\"\u003c\u003cendl; } 析构函数使用 #include \u003ciostream\u003e#include \"Student.h\"using namespace std; int main(int argc,char ** argv) { Student stu; return 0; } /** 输出： Student::Student() Student::~Student() / ","date":"2022-07-16","objectID":"/cppcalss/:1:1","tags":["C++","类","对象","构造函数","析构函数"],"title":"C++ 类 和对象 构造函数、析构函数","uri":"/cppcalss/"},{"categories":["编程学习"],"content":"对象调用公有成员 // Student.h // Created by 范兴国 on 2022/7/12. // #ifndef STLLEN_STUDENT_H #define STLLEN_STUDENT_H #include \u003cstring\u003eusing namespace std; class Student{ public: char name[20]; double score; void introduce(); Student(); ~Student(); }; #endif //STLLEN_STUDENT_H // Student.cpp // Created by 范兴国 on 2022/7/12. // #include \"Student.h\"#include \u003ciostream\u003e using namespace std; Student::Student() { cout\u003c\u003c\"Student::Student()\"\u003c\u003cendl; } void Student::introduce() { cout\u003c\u003cname\u003c\u003cendl; cout\u003c\u003cscore\u003c\u003cendl; } Student::~Student() { cout\u003c\u003c\"Student::~Student()\"\u003c\u003cendl; } // main.cpp #include \u003ciostream\u003e#include \u003cstring.h\u003e#include \"Student.h\"using namespace std; int main(int argc,char ** argv) { Student stu; // 修改成员属性 strncpy(stu.name,\"Tom\",20); stu.score=100; stu.introduce(); Student * pStu2; //使用指针 pStu2=\u0026stu; pStu2-\u003escore=99; // 分量运算符 访问成员变量 pStu2-\u003eintroduce(); return 0; } ","date":"2022-07-16","objectID":"/cppcalss/:1:2","tags":["C++","类","对象","构造函数","析构函数"],"title":"C++ 类 和对象 构造函数、析构函数","uri":"/cppcalss/"},{"categories":["编程学习"],"content":"使用c++命名空间namespace，和输入输出 cin和cout ","date":"2022-07-16","objectID":"/namespacecincout/:0:0","tags":["C++","cin","cout","命名空间"],"title":"C++ 命名空间和cin、cout","uri":"/namespacecincout/"},{"categories":["编程学习"],"content":"在头文件中声明 #ifndef STLLEN_STUDENT_H #define STLLEN_STUDENT_H #include \u003cstring\u003e //命名空间的声明 namespace iotek{ extern int val; //全局变量 void func(); //声明函数 } #endif //STLLEN_STUDENT_H ","date":"2022-07-16","objectID":"/namespacecincout/:0:1","tags":["C++","cin","cout","命名空间"],"title":"C++ 命名空间和cin、cout","uri":"/namespacecincout/"},{"categories":["编程学习"],"content":"在源文件中定义 #include \"Student.h\"#include \u003ciostream\u003e// 命名空间函数定义，名称前面加：空间名和两个冒号 int iotek::val=0;// 全局变量定义 void iotek::func() { // 命名空间 函数定义 cout\u003c\u003c\"Hello World !\"\u003c\u003cendl; } ","date":"2022-07-16","objectID":"/namespacecincout/:0:2","tags":["C++","cin","cout","命名空间"],"title":"C++ 命名空间和cin、cout","uri":"/namespacecincout/"},{"categories":["编程学习"],"content":"在主文件中使用 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cmap\u003e#include \"Student.h\"//using namespace std; // 命名空间的指定 using iotek::func;//方法1,下面 func 函数是 iotek的 using namespace iotek; //方法3 int main() { func();//方法1 iotek::func();// 方法2 调用 func(); //方法3 return 0; } ","date":"2022-07-16","objectID":"/namespacecincout/:0:3","tags":["C++","cin","cout","命名空间"],"title":"C++ 命名空间和cin、cout","uri":"/namespacecincout/"},{"categories":["编程学习"],"content":"C++ 输入输出 ","date":"2022-07-16","objectID":"/namespacecincout/:1:0","tags":["C++","cin","cout","命名空间"],"title":"C++ 命名空间和cin、cout","uri":"/namespacecincout/"},{"categories":["编程学习"],"content":"使用cin、cout的准备工作 #include \u003ciostream\u003e //引入头文件using namespace std; //使用命名空间std ","date":"2022-07-16","objectID":"/namespacecincout/:1:1","tags":["C++","cin","cout","命名空间"],"title":"C++ 命名空间和cin、cout","uri":"/namespacecincout/"},{"categories":["编程学习"],"content":"使用cout输出 **输出单个对象：**cout«要输出的对象； **输出多个对象：**cout«要输出的对象1«要输出的对象2； **换行：**cout«要输出的对象«endl; #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cmap\u003e#include \"Student.h\"using namespace std; int main(int argc,char ** argv) { // 使用cout输出 int num=45; char str[20]=\"hello world\"; cout\u003c\u003cnum\u003c\u003cendl; cout\u003c\u003cstr\u003c\u003cendl; cout\u003c\u003cnum\u003c\u003cstr\u003c\u003cendl;// 连续输出 //使用cin输入,基本类型、字符数组、string类型 return 0; } ","date":"2022-07-16","objectID":"/namespacecincout/:1:2","tags":["C++","cin","cout","命名空间"],"title":"C++ 命名空间和cin、cout","uri":"/namespacecincout/"},{"categories":["编程学习"],"content":"使用cin输入 使用cin输入,类型包括：基本类型、字符数组、string类型 **输入单个基本数据类型、单个字符：**cin»存放输入数据对象 默认使用空白（空格、回车）为输入结束 #include \u003ciostream\u003e using namespace std; int main(int argc,char ** argv) { //使用cin输入,基本类型、字符数组、string类型 int num=0; char str[20]={0}; cout\u003c\u003c\"Input a num:\"; cin\u003e\u003enum; cout\u003c\u003c\"Input a str:\"; cin\u003e\u003estr; cout\u003c\u003cstr\u003c\u003cendl; cout\u003c\u003cnum\u003c\u003cendl; return 0; } cin 无法接收 空格、Tab、回车 ","date":"2022-07-16","objectID":"/namespacecincout/:1:3","tags":["C++","cin","cout","命名空间"],"title":"C++ 命名空间和cin、cout","uri":"/namespacecincout/"},{"categories":["编程学习"],"content":"使用esp32 物联网模块，MicroPython 语言，开发一个数码管超声波实时距离的工具。 4位8段数码管接线 # 接线全点亮测试 import machine, time trig = machine.Pin(15,machine.Pin.OUT) echo = machine.Pin(2,machine.Pin.IN) # 需要根据实际接线，依次放入A/B/C/D/E/F/G/DP这8个段位led灯对应到esp8266的GPIO引脚 # 接线对应引脚，如下代码所示例如 esp32中27引脚，对应数码管a，即数码管2号引脚 low=[27,26,25,4,5,18,19,21] ledLow=[] s1=machine.Pin(13,machine.Pin.OUT) # s1 为数码管SEG1，esp32 13引脚接数码管 1引脚 s2=machine.Pin(12,machine.Pin.OUT) s3=machine.Pin(14,machine.Pin.OUT) s4=machine.Pin(23,machine.Pin.OUT) for pin in low: ledLow.append(machine.Pin(pin,machine.Pin.OUT)) for led in ledLow: led.value(0) s1.value(1) s2.value(1) s3.value(1) s4.value(1) # 超声波测距，测试 import machine, time trig = machine.Pin(2,machine.Pin.OUT) echo = machine.Pin(4,machine.Pin.IN) def distance(): trig.value(1) time.sleep_us(10) trig.value(0) while echo.value() == 0: pass while echo.value() == 1: ts = time.ticks_us() while echo.value() == 1: pass te = time.ticks_us() tc = te - ts distance = round((tc*170)/10000, 2) return distance while True: dist = distance() print('distance:', dist, 'cm') time.sleep(2) 最后附上完整代码 # 数码管实时显示超声波测量距离 import machine from machine import Pin import utime import _thread,time import sys trig = machine.Pin(15,machine.Pin.OUT) echo = machine.Pin(2,machine.Pin.IN) stop = Pin(22,machine.Pin.IN) a_lock = _thread.allocate_lock() numA = 99 leds = [] # 需要根据实际接线，依次放入A/B/C/D/E/F/G/DP这8个段位led灯对应到esp8266的GPIO引脚 for p in [27,25,19,5,4,26,21,18]: _pin = Pin(p, Pin.OUT) leds.append(_pin) digs = [] # 根据实际接线，依次控制1~4四个位置的数码管 for p in [13,12,14,23]: # 实际目前只控制两位，还借用了原DP引脚的接线 _pin = Pin(p, Pin.OUT) digs.append(_pin) mapper = { '0': 0xC0, '1': 0xF9, '2': 0xA4, '3': 0xB0, '4': 0x99, '5': 0x92, '6': 0x82, '7': 0xF8, '8': 0x80, '9': 0x90, 'A': 0x88, 'B': 0x83, 'C': 0xA7, 'D': 0xA1, 'E': 0x86, 'F': 0x8E, } def show_num(num, has_point=False): '写入显示字符，转换为十六进制数值并按位点亮' value = mapper.get(num, 0) if not value: return value = value \u0026 0x7F if has_point else value # 共阳方式 # value = (~value | 0x80) if has_point else ~value # 共阴方式 for i,led in enumerate(leds): # if i==7: continue # !!!临时屏蔽最高位（转为控制管位开关） led.value((value \u003e\u003e i) \u0026 0x01) def showResu(): while True: with a_lock: num=numA for i in range(100): if len(str(num))==4: # 显示千位 show_num(str(int(num/1000))) digs[0].on() utime.sleep_ms(1) digs[0].off() utime.sleep_ms(1) if len(str(num))\u003e=3: # 显示百位 show_num(str(int(num/100%10))) digs[1].on() utime.sleep_ms(1) digs[1].off() utime.sleep_ms(1) if len(str(num))\u003e=2: # 显示十位 show_num(str(int((num/10)%10)),True) digs[2].on() utime.sleep_ms(1) digs[2].off() utime.sleep_ms(1) if len(str(num))==1: # 显示十位 show_num(str(0),True) digs[2].on() utime.sleep_ms(1) digs[2].off() utime.sleep_ms(1) # 显示个位 show_num(str(num%10)) digs[3].on() utime.sleep_ms(1) digs[3].off() utime.sleep_ms(1) else: # 显示个位 show_num(str(num%10)) digs[3].on() utime.sleep_ms(1) digs[3].off() utime.sleep_ms(1) def distance(): trig.value(1) time.sleep_us(10) trig.value(0) while echo.value() == 0: pass while echo.value() == 1: ts = time.ticks_us() while echo.value() == 1: pass te = time.ticks_us() tc = te - ts distance = round((tc*170)/10000, 1) return distance _thread.start_new_thread(showResu, ())#启动线程 while True: with a_lock: numA=int(distance()*10) print(numA) time.sleep(0.8) if stop.value()==0: sys.exit() ","date":"2022-07-14","objectID":"/esp32distance/:0:0","tags":["esp32","超声波测距","数码管","micropython"],"title":"esp32 micropython 超声波测距+数码管显示","uri":"/esp32distance/"},{"categories":["编程学习"],"content":"帮助文档：https://cplusplus.com/ 存储任意相同数据类型的数据，容量大小可变的数组 ","date":"2022-07-12","objectID":"/vectoriterator/:0:0","tags":["C++","数组","vector","迭代器"],"title":"C++ 数组（vector）和迭代器","uri":"/vectoriterator/"},{"categories":["编程学习"],"content":"数组 ","date":"2022-07-12","objectID":"/vectoriterator/:1:0","tags":["C++","数组","vector","迭代器"],"title":"C++ 数组（vector）和迭代器","uri":"/vectoriterator/"},{"categories":["编程学习"],"content":"使用方法 包含头文件，以及使用命名空间std ","date":"2022-07-12","objectID":"/vectoriterator/:1:1","tags":["C++","数组","vector","迭代器"],"title":"C++ 数组（vector）和迭代器","uri":"/vectoriterator/"},{"categories":["编程学习"],"content":"具体使用 存放、读取、删除 #include \u003ciostream\u003e#include \u003cstring\u003e#include \"../lib/mystr.h\"#include \"Student.h\"#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int main() { vector\u003cint\u003e arr; arr.push_back(1);//存放一个数 arr.push_back(2); arr.push_back(3); // 数组arr:[1,2,3] cout\u003c\u003carr[2]\u003c\u003cendl;//打印第三个数，显示：3 arr.pop_back();//从后面弹出一个数,arr:[1,2] arr.push_back(7);//arr:[1,2,7] cout\u003c\u003carr[2]\u003c\u003cendl;//打印第二个数，显示：7 return 0; } 排序 #include \u003ciostream\u003e#include \u003cstring\u003e#include \"../lib/mystr.h\"#include \"Student.h\"#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int main() { vector\u003cint\u003e arr; arr.push_back(3); arr.push_back(1); arr.push_back(4); arr.push_back(1); arr.push_back(5); sort(arr.begin(),arr.end()); for (int i = 0; i \u003c 4; ++i) { cout\u003c\u003carr[i]\u003c\u003c\",\"; } return 0; } //输出：1,1,3,4, 自定义排序 如果我们自定义一个学生类，如何还是按照上述方法进行排序，c++是不知道如何排序，就比如对学生是按照升高，成绩还是按照其他的排序，于是要定义排序的方式，即stuCmp函数。 首先定义学生类 //Student.h // // Created by 范兴国 on 2022/7/12. // #ifndef STLLEN_STUDENT_H #define STLLEN_STUDENT_H #include \u003cstring\u003e using namespace std; class Student{ private: int id; string name; public: Student(const string \u0026 name,int id); int getId()const; void Introduce()const; }; #endif //STLLEN_STUDENT_H //Student.cpp // // Created by 范兴国 on 2022/7/12. // #include \"Student.h\"#include \u003ciostream\u003e using namespace std; Student::Student(const string \u0026name, int id):name(name),id(id){} int Student::getId() const { return id; } void Student::Introduce() const { cout\u003c\u003cid\u003c\u003c\":\"\u003c\u003cname\u003c\u003cendl; } 然后进行排序 #include \u003ciostream\u003e#include \u003cstring\u003e#include \"../lib/mystr.h\"#include \"Student.h\"#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; // 定义排序函数，按照id匿名排序 bool stuCmp(const Student \u0026 stu1,const Student stu2){ return stu1.getId()\u003estu2.getId(); } int main() { vector\u003cStudent\u003e students; for (int i = 0; i \u003c 10; ++i) { Student stu(\"Tom\",i); students.push_back(stu); } sort(students.begin(),students.end(), stuCmp); for (int i = 0; i \u003c 10; ++i) { students[i].Introduce(); } return 0; } /* 输出： 9:Tom 8:Tom 7:Tom 6:Tom 5:Tom 4:Tom 3:Tom 2:Tom 1:Tom 0:Tom */ ","date":"2022-07-12","objectID":"/vectoriterator/:1:2","tags":["C++","数组","vector","迭代器"],"title":"C++ 数组（vector）和迭代器","uri":"/vectoriterator/"},{"categories":["编程学习"],"content":"迭代器 迭代器是一个对象，能够用来遍历标准模板库中的部分或者全部元素 ","date":"2022-07-12","objectID":"/vectoriterator/:2:0","tags":["C++","数组","vector","迭代器"],"title":"C++ 数组（vector）和迭代器","uri":"/vectoriterator/"},{"categories":["编程学习"],"content":"具体使用 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003eusing namespace std; int main() { vector\u003cint\u003e arr; vector\u003cint\u003e::iterator it; for (int i = 0; i \u003c 10; ++i) { arr.push_back(i); } for (it=arr.begin();it!=arr.end();it++) { cout\u003c\u003c*it\u003c\u003c\",\"; } return 0; } //输出：0,1,2,3,4,5,6,7,8,9, ","date":"2022-07-12","objectID":"/vectoriterator/:2:1","tags":["C++","数组","vector","迭代器"],"title":"C++ 数组（vector）和迭代器","uri":"/vectoriterator/"},{"categories":["编程学习"],"content":"对自定义类进行遍历 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \"Student.h\"using namespace std; int main() { vector\u003cStudent\u003e stus; for (int i = 0; i \u003c 10; ++i) { Student stu(\"Tom\",i); stus.push_back(stu); } vector\u003cStudent\u003e::iterator it; for(it=stus.begin();it!=stus.end();it++){ it-\u003eIntroduce(); } return 0; } /* 输出： 0:Tom 1:Tom 2:Tom 3:Tom 4:Tom 5:Tom 6:Tom 7:Tom 8:Tom 9:Tom */ ","date":"2022-07-12","objectID":"/vectoriterator/:2:2","tags":["C++","数组","vector","迭代器"],"title":"C++ 数组（vector）和迭代器","uri":"/vectoriterator/"},{"categories":["编程学习"],"content":"迭代器失效 当容器元素增加删除，迭代器可能失效 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \"Student.h\"using namespace std; int main() { vector\u003cint\u003e arr; for (int i = 0; i \u003c 10; ++i) { arr.push_back(i); } vector\u003cint\u003e::iterator it; it=arr.end()-1; cout\u003c\u003c*it\u003c\u003cendl; arr.pop_back();// 删除最后一个元素 cout\u003c\u003c*it\u003c\u003cendl; return 0; } /*输出： 9 9 */ 虽然迭代器最后一个元素可以访问，但是这样是非常危险的。 ","date":"2022-07-12","objectID":"/vectoriterator/:2:3","tags":["C++","数组","vector","迭代器"],"title":"C++ 数组（vector）和迭代器","uri":"/vectoriterator/"},{"categories":["编程学习"],"content":"介绍泛型的概念，以及在C++中如何使用。 ","date":"2022-07-11","objectID":"/cppgeneric/:0:0","tags":["C++","泛型"],"title":"C++ 泛型编程","uri":"/cppgeneric/"},{"categories":["编程学习"],"content":"函数模板 ","date":"2022-07-11","objectID":"/cppgeneric/:1:0","tags":["C++","泛型"],"title":"C++ 泛型编程","uri":"/cppgeneric/"},{"categories":["编程学习"],"content":"函数模板 定义一个函数，判断两个值是否相等，如果有很多类型（如整型、浮点型），那么需要定义不同类型的参数判断，例如 bool isEqual(int a,int b){ return a==b; } bool isEqual(float a,float b){ return a==b; } 但是如果类型太多，要一个个写不同类型太过繁琐了，可不可以把不同类型用一个符号表示，用编译器判断类型，然后传递不同类型参数，做出不同类型的运算。这就是函数模板，上述内容使用模板定义如下所示： template\u003ctypename T\u003e bool isEqual(T a,T b){ return a==b; } 这样可以实现不同类型的“批量”定义函数了。 ","date":"2022-07-11","objectID":"/cppgeneric/:1:1","tags":["C++","泛型"],"title":"C++ 泛型编程","uri":"/cppgeneric/"},{"categories":["编程学习"],"content":"函数模板特化 并不是所有类型都能用a==b来判断的，比如 字符串，因此对于特定类型的判断，需要做针对型的处理，这就是函数模板的特化。针对于string 的特殊比较，作如下函数模板特化 template\u003c\u003e bool isEqual\u003cchar *\u003e(char * a,char * b){ return strcmp(a,b)==0; // #include \u003cstring\u003e } ","date":"2022-07-11","objectID":"/cppgeneric/:1:2","tags":["C++","泛型"],"title":"C++ 泛型编程","uri":"/cppgeneric/"},{"categories":["编程学习"],"content":"类模板 ","date":"2022-07-11","objectID":"/cppgeneric/:2:0","tags":["C++","泛型"],"title":"C++ 泛型编程","uri":"/cppgeneric/"},{"categories":["编程学习"],"content":"类模板 如果实现不同类型的数组类，并且功能相近，比如 实现一个 int数组类，和一个float数组类，其中功能包括添加元素、查看元素，这样一个个实现起来非常繁琐。可不可以用函数模板的方法，实现一个类模板。下面就是类模板的定义，类模板 如果分开写，头文件写声明，源文件写 函数实现，编译器容易报错，这里采用定义和实现 写在同一个头文件中 目录结构 //mystr.h // // Created by 范兴国 on 2022/7/10. // #ifndef STLLEN_MYSTR_H #define STLLEN_MYSTR_H template\u003ctypename T\u003e class MyArray{ private: T data[20]; int len; public: MyArray(); T indexOf(int index); void addValue(T value); }; template\u003ctypename T\u003e MyArray\u003cT\u003e::MyArray():len(0){} template\u003ctypename T\u003e T MyArray\u003cT\u003e::indexOf(int index) { return data[index]; } template\u003ctypename T\u003e void MyArray\u003cT\u003e::addValue(T value) { data[len]=value; len++; } #endif //STLLEN_MYSTR_H 再在实现文件 mystr.cpp 引入下 //mystr.cpp // // Created by 范兴国 on 2022/7/10. // #include \u003ciostream\u003e#include \"mystr.h\" main文件 #include \u003ciostream\u003e#include \u003cstring\u003e#include \"../lib/mystr.h\"using namespace std; int main() { MyArray\u003cint\u003e arr; for (int i = 0; i \u003c10; ++i) { arr.addValue(i); } for (int i = 0; i \u003c 10; ++i) { cout\u003c\u003carr.indexOf(i)\u003c\u003cendl; } return 0; } ","date":"2022-07-11","objectID":"/cppgeneric/:2:1","tags":["C++","泛型"],"title":"C++ 泛型编程","uri":"/cppgeneric/"},{"categories":["编程学习"],"content":"类模板特化（针对类中所有的泛型） 与函数模板同理，类模板特化实现如下 // // Created by 范兴国 on 2022/7/10. // #include \u003ciostream\u003e#ifndef STLLEN_MYSTR_H #define STLLEN_MYSTR_H using namespace std; template\u003ctypename T\u003e class MyArray{ private: T data[20]; int len; public: MyArray(); T indexOf(int index); void addValue(T value); }; template\u003ctypename T\u003e MyArray\u003cT\u003e::MyArray():len(0){} template\u003ctypename T\u003e T MyArray\u003cT\u003e::indexOf(int index) { return data[index]; } template\u003ctypename T\u003e void MyArray\u003cT\u003e::addValue(T value) { data[len]=value; len++; } template\u003c\u003e //类模板 对float 特化 class MyArray\u003cfloat\u003e{ public: MyArray(); }; MyArray\u003cfloat\u003e::MyArray(){ cout\u003c\u003c\"float\"\u003c\u003cendl; } #endif //STLLEN_MYSTR_H main文件 #include \u003ciostream\u003e#include \u003cstring\u003e#include \"../lib/mystr.h\"using namespace std; int main() { MyArray\u003cfloat\u003e arr;//输出：float return 0; } ","date":"2022-07-11","objectID":"/cppgeneric/:2:2","tags":["C++","泛型"],"title":"C++ 泛型编程","uri":"/cppgeneric/"},{"categories":["编程学习"],"content":"类模板偏特化（指定部分泛型） // // Created by 范兴国 on 2022/7/10. // #include \u003ciostream\u003e#ifndef STLLEN_MYSTR_H #define STLLEN_MYSTR_H using namespace std; template\u003ctypename T1,typename T2\u003e class Pair{ private: T1 first; T2 second; public: Pair(); }; template\u003ctypename T1,typename T2\u003e Pair\u003cT1,T2\u003e::Pair() { cout\u003c\u003c\"T1,T2\"\u003c\u003cendl; } template\u003ctypename T2\u003e class Pair\u003cchar,T2\u003e{ public: Pair(); }; template\u003ctypename T2\u003e Pair\u003cchar,T2\u003e::Pair() { cout\u003c\u003c\"char,T2\"\u003c\u003cendl; } #endif //STLLEN_MYSTR_H 对应main文件 #include \u003ciostream\u003e#include \u003cstring\u003e#include \"../lib/mystr.h\"using namespace std; int main() { Pair\u003cint,int\u003eps; Pair\u003cchar,int\u003ep2; return 0; //输出： //T1,T2 //char,T2 } ","date":"2022-07-11","objectID":"/cppgeneric/:2:3","tags":["C++","泛型"],"title":"C++ 泛型编程","uri":"/cppgeneric/"},{"categories":["编程学习"],"content":"如果一个main文件如果包含太多类、函数，代码可以达到几千行，不利于项目管理。一种方法是，将一些类或者函数，写在另一个文件里面（头文件、库），到时候像引入iostream头文件一样引入自己写的库，在编译运行的时候，把自己的库编译好，连接到 可执行文件里面即可。 ","date":"2022-07-10","objectID":"/cppdemocreation/:0:0","tags":["C++","项目构建","头文件","cmake"],"title":"C++项目构建","uri":"/cppdemocreation/"},{"categories":["编程学习"],"content":"构建项目的目录结构 ","date":"2022-07-10","objectID":"/cppdemocreation/:1:0","tags":["C++","项目构建","头文件","cmake"],"title":"C++项目构建","uri":"/cppdemocreation/"},{"categories":["编程学习"],"content":"文件介绍 # tree . ├── CMakeLists.txt # 项目目录下文件 ├── build │ └── bin ├── lib │ ├── CMakeLists.txt # 用于生成相关库文件 │ ├── mystr.cpp # 自定义的库 │ └── mystr.h # 自定义的头文件 └── src ├── CMakeLists.txt # 用于生成可执行文件，同时将库链接到可执行文件中 └── main.cpp # 主函数入口 ","date":"2022-07-10","objectID":"/cppdemocreation/:2:0","tags":["C++","项目构建","头文件","cmake"],"title":"C++项目构建","uri":"/cppdemocreation/"},{"categories":["编程学习"],"content":"代码文件内容 //main.cpp （位于src目录下） #include \u003ciostream\u003e#include \u003cstring\u003e#include \"../lib/mystr.h\"using namespace std; int main() { MyStr s; const char *m= s.c_str(); cout\u003c\u003c\"hello\"\u003c\u003cendl; return 0; } // mystr.h （位于lib目录下） // // Created by 范兴国 on 2022/7/10. // #ifndef STLLEN_MYSTR_H #define STLLEN_MYSTR_H class MyStr{ private: char * m_str; public: MyStr(); public: const char * c_str()const; public: ~MyStr(); }; #endif //STLLEN_MYSTR_H //mystr.cpp （位于lib目录下） // // Created by 范兴国 on 2022/7/10. // #include \u003ciostream\u003e#include \"mystr.h\"MyStr::MyStr(){ m_str=new char('\\0'); } const char * MyStr:: c_str()const{ return m_str; } MyStr::~MyStr(){ if(NULL!=m_str){ delete[] m_str; } } ","date":"2022-07-10","objectID":"/cppdemocreation/:3:0","tags":["C++","项目构建","头文件","cmake"],"title":"C++项目构建","uri":"/cppdemocreation/"},{"categories":["编程学习"],"content":"cmake文件内容 ","date":"2022-07-10","objectID":"/cppdemocreation/:4:0","tags":["C++","项目构建","头文件","cmake"],"title":"C++项目构建","uri":"/cppdemocreation/"},{"categories":["编程学习"],"content":"项目中 CMakeLists.txt cmake_minimum_required(VERSION 3.12.3)project(stlLen)set(CMAKE_CXX_STANDARD 14)include_directories(\"./lib\")link_directories(build/bin/)add_subdirectory(lib bin) # 这里先编译库，然后再编译可执行文件 #add_subdirectory(src bin) ","date":"2022-07-10","objectID":"/cppdemocreation/:4:1","tags":["C++","项目构建","头文件","cmake"],"title":"C++项目构建","uri":"/cppdemocreation/"},{"categories":["编程学习"],"content":"lib目录下的CMakeLists.txt SET(LIBMYSTR_SRC mystr.cpp)ADD_LIBRARY(mystr_static STATIC ${LIBMYSTR_SRC})SET_TARGET_PROPERTIES(mystr_static PROPERTIES OUTPUT_NAME \"mystr\")SET_TARGET_PROPERTIES(mystr_static PROPERTIES CLEAN_DIRECT_OUTPUT 1) ","date":"2022-07-10","objectID":"/cppdemocreation/:4:2","tags":["C++","项目构建","头文件","cmake"],"title":"C++项目构建","uri":"/cppdemocreation/"},{"categories":["编程学习"],"content":"src目录下的CMakeLists.txt add_executable(str main.cpp)target_link_libraries(str libmystr.a) ","date":"2022-07-10","objectID":"/cppdemocreation/:4:3","tags":["C++","项目构建","头文件","cmake"],"title":"C++项目构建","uri":"/cppdemocreation/"},{"categories":["编程学习"],"content":"项目构建步骤 ","date":"2022-07-10","objectID":"/cppdemocreation/:5:0","tags":["C++","项目构建","头文件","cmake"],"title":"C++项目构建","uri":"/cppdemocreation/"},{"categories":["编程学习"],"content":"1、编写好代码 参考上述代码 ","date":"2022-07-10","objectID":"/cppdemocreation/:5:1","tags":["C++","项目构建","头文件","cmake"],"title":"C++项目构建","uri":"/cppdemocreation/"},{"categories":["编程学习"],"content":"2、编译自定义库文件 主目录CMakeLists.txt cmake_minimum_required(VERSION 3.12.3)project(stlLen)set(CMAKE_CXX_STANDARD 14)include_directories(\"./lib\")link_directories(build/bin/)add_subdirectory(lib bin)#add_subdirectory(src bin) # 注释掉 编译可执行文件，先编译相关库 进入 build目录，先执行“cmake ..”，再执行“make” FanXingGuo@fanxingguodeMacBook-Pro build % cmake .. -- The C compiler identification is AppleClang 11.0.0.11000033 -- The CXX compiler identification is AppleClang 11.0.0.11000033 -- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc -- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ -- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ -- works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- Configuring done -- Generating done -- Build files have been written to: /Users/FanXingGuo/CLionProjects/stlLen/build FanXingGuo@fanxingguodeMacBook-Pro build % make Scanning dependencies of target mystr_static [ 50%] Building CXX object bin/CMakeFiles/mystr_static.dir/mystr.cpp.o [100%] Linking CXX static library libmystr.a [100%] Built target mystr_static FanXingGuo@fanxingguodeMacBook-Pro build % 可见bin目录中已生成libmystr.a文件 ","date":"2022-07-10","objectID":"/cppdemocreation/:5:2","tags":["C++","项目构建","头文件","cmake"],"title":"C++项目构建","uri":"/cppdemocreation/"},{"categories":["编程学习"],"content":"3、编译可执行文件，并链接到自己的库 主目录CMakeLists.txt cmake_minimum_required(VERSION 3.12.3)project(stlLen)set(CMAKE_CXX_STANDARD 14)include_directories(\"./lib\")link_directories(build/bin/)#add_subdirectory(lib bin) # 注释掉库编译过程，取消注释 可执行文件编译过程 add_subdirectory(src bin) 在build目录下，执行：make，即可 FanXingGuo@fanxingguodeMacBook-Pro build % make -- Configuring done -- Generating done -- Build files have been written to: /Users/FanXingGuo/CLionProjects/stlLen/build Scanning dependencies of target str [ 50%] Building CXX object bin/CMakeFiles/str.dir/main.cpp.o [100%] Linking CXX executable str [100%] Built target str FanXingGuo@fanxingguodeMacBook-Pro build % 可见，可执行文件已生成 最后，测试一下编译的程序 FanXingGuo@fanxingguodeMacBook-Pro build % cd bin FanXingGuo@fanxingguodeMacBook-Pro bin % ./str hello FanXingGuo@fanxingguodeMacBook-Pro bin % ","date":"2022-07-10","objectID":"/cppdemocreation/:5:3","tags":["C++","项目构建","头文件","cmake"],"title":"C++项目构建","uri":"/cppdemocreation/"},{"categories":["编程学习"],"content":"总结 构建自己的项目，首先是编写好程序代码，然后编写好相关的cmake文件，这里要区别lib和src目录下的内容。最后，分别编译库文件和可执行文件即可。 ","date":"2022-07-10","objectID":"/cppdemocreation/:6:0","tags":["C++","项目构建","头文件","cmake"],"title":"C++项目构建","uri":"/cppdemocreation/"},{"categories":["学习方法"],"content":"学习方法，应从三个要点、三个维度去分析，做到实事求是、根据自身情况调整学习策略，才能取得长远的进步。 ","date":"2022-05-28","objectID":"/learnmethods/:0:0","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"三个维度 ","date":"2022-05-28","objectID":"/learnmethods/:1:0","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"1、学习能力：先知先觉 后知后觉 不知不觉 在不同方面 不同领域，有的人先知先觉，学的快，考试成绩也很棒，有的人则是后知后觉 是勤奋，日积月累不断做题不断反馈掌握知识；还有一种人，不知不觉，即做题和实践也提升不大，或许是因为智力或者非理性因素吧 ","date":"2022-05-28","objectID":"/learnmethods/:1:1","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"2、知识掌握：生产关系适应生产力水平 同生产关系 适应生产力水平，学习方法要 适应知识基础水平。一开始学习，什么都不懂，重点在掌握；课本学完后面对遗忘，然后是巩固；巩固好 对知识点 手到擒来，然后是提升 题海战术。 ","date":"2022-05-28","objectID":"/learnmethods/:1:2","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"3、答题正义 题目正义：应适应考试内在的规则、要求和技巧。如果选择了考试升学的道路，就应集中精力，努力取得好成绩。学习知识的范围应紧扣考试大纲，题目即正义，考试考不到的、考试用不着的，可以先不学。 越难的题目，越是来自于平时坚持不懈的做题和积累。 ","date":"2022-05-28","objectID":"/learnmethods/:1:3","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"学习的过程 学习的三个层次：基础、强化、拔高 ","date":"2022-05-28","objectID":"/learnmethods/:2:0","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"掌握基础，抓理解、抓做基础题。 一开始，学习课本内容，学习的主要矛盾在知识掌握和理解，这时候，班主任的工作是负责落实好学生知识点的理解和记忆，主要工作就是抓理解和抓做基础题。 课堂要落实到笔记，笔记要落实到重复。听课不记笔记，很难保证未来不会忘记课上的重点内容。记笔记是一种很好的方式，来帮助自己建立系统知识体系和记录遇到书本没有的内容。很多时候，学生不缺理性的认识，而是缺少感性的认识，这时候给他们谈谈自己的理解，帮助他们串一串知识，后期可以隔三差五提一提之前讲过的内容，可以帮助他们掌握知识。 做基础题落实到正确理解，理解落实到重复。对于做题，侧重点是在于更好的理解知识，而不是上手做一些有难度的题目。课本的典型例题、思考题等等，都是帮助理解知识的。这一时期，做题侧重在检验自己的认识，巩固基础，通过做题发现自己的不足，打牢基础。而错题的反馈，错因应多集中在在对知识点的理解上，如果错因多集中在解题思路方面，则说明知识方面掌握的很好了。在后期学习新内容过程中，要时不时回头看看错题和知识，强化记忆。 ","date":"2022-05-28","objectID":"/learnmethods/:2:1","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"强化知识，抓刷题、抓错题 随着学习课程的尾声和临近考试，在基础知识打牢的情况下，应当多刷题。刷题，即是一种复习学过知识的好办法，又能够让自己见多识广，拓展自己解题思路。分析这一时期做题的错因，主要矛盾不再是知识点掌握，而是转移到解题思路方面。在回顾错题时，往往错因是理解偏差或者解题思路存在问题，基本的知识点懂但却联系不上，便是在这个阶段的问题。 错题要落实到找到正确思路，正确思路要落实到多次重复。举一个例子，有一次我从顶楼走楼梯的时候，不自觉按以往方式直着身子下楼，房顶顶越走越低，然后超出高度预估，碰着脑袋了。好痛，然后我忍住疼痛，练习当走到最后几步台阶时低头，重复和许多次。这样后来，除了一次是下楼思考事情碰着了，其他都没有碰头。 错题要寻找正确的思路，用正确的思路做题重复几次，来建立大脑的神经连接，然后再遇到类似的情况，犯错的情况就少了，当然有时候没有及时巩固正确思路，也有可能恢复原样。所以及时翻看错题，很重要。同样的，对于一些知识点掌握不到位的地方，可以建立一个大纲，标记知识盲区，后期复习时侧重先回顾那些难理解的知识。 ","date":"2022-05-28","objectID":"/learnmethods/:2:2","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"强化之后，拔高 在经历过题海战术后，过滤的错题，分析其错因，此时，学习的主要矛盾不是在解题思路方面，而是侧重学习能力和思考能力。这一类错因，要么是给出新定义现学现用很难适应，要么是推导逻辑过于复杂，两种都不是简单的转变解题思路，而是对学生需要一定的学习能力和思考能力。能走到这里的学生，往往是能力过于常人的，要么是有一定天赋的，要么是非常勤奋的。 拔高期，主要矛盾是面对的数学难题，其他的物理、化学、生物 一般出不了很难的拔高题，而数学则可以是出拔高题的天地。换句话说，错题本里面的拔高题，数学占比会越来越大，说明这是在拔高期。 当感觉自己有压力，有难度的时候，如同是上楼走楼梯的感觉沉重，这其实是在走上坡路。越是难的题目，越是更高层次的教育在招手，因此要迎难而上，拿这类题目练练手，提高自己的学习能力和思考能力。 ","date":"2022-05-28","objectID":"/learnmethods/:2:3","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"实践经历 以上总结的三个层次，学习能力是对一般学生而言的，在遇到不同学习能力的学生，有的会进程的快一些，有的会进程慢一些，因此要根据不同学生的实际情况，因材施教：对进度慢的学生，不要拔苗助长，对进度快的学生，也不能让他原地踏步。 ","date":"2022-05-28","objectID":"/learnmethods/:3:0","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"理解力 遇到一个学生，一直在学习很勤奋，有的科目，当其他同学走到在强化基础或者拔高时，她在仍第一层。通过仔细观察，发现虽然她确实很用功学习，但是不能理解书本知识，好比是他可以记住一个句子，但是不理解句子的含义，因此直来直去的提问能够回答，但是变化形式，却不能很好应对。整体上看，经过一个阶段的学习，他是有进步的，同时缺少一定的理解能力，使他不能在学习方面展翅高飞。对待这样学生的态度，首先人与人不同，理解力偏弱，不应责怪孩子，而且他，然后应多给他串一串知识，多讲一些自己的理解，帮助他理解。 ","date":"2022-05-28","objectID":"/learnmethods/:3:1","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"用学生理解的方式 在辅导实践过程中，我深刻理解要让自己成为”初中知识“的专家。起初我以为，告诉学生一些学习方法，落实好这些，可以达到事半功倍的效果，但是发现学生并不理解这些学习方法，尽管我给他们说的很详细而且也举过例子，但往往他们面对这些有些无动于衷。后来思考，或许自己的频率太高，他们接收不到这些抽象的内容，后来转变思路，在学生学习的知识维度（范围），通过提问错题、知识的方式，和他们一样的知识频率，启发他们，渐渐的我发现这起到了一定效果。 ","date":"2022-05-28","objectID":"/learnmethods/:3:2","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"标记知识盲区 再后来，在学完课本内容后，我打印出提纲（考试大纲），通过提问和错题，标记出他们知识薄弱地方，然后进行重点提问知识和错题，以此引起学生的注意。不过，后期也有的学生，课本知识掌握偏弱，主要矛盾还不能过渡到标记知识盲区，标记的更多意义在于引起注意，或者说展示一个更好的学习方法。 ","date":"2022-05-28","objectID":"/learnmethods/:3:3","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"先复习所学，后做题 在做题的时候，先温习一遍知识再做题是很有效的方式，这样会由浅入深，加深知识理解和应用。在提醒学生做题前看看知识，发现能够落实的不多。后来我改变策略，提问课堂老师所讲内容，这样如果回答上来，对他们是温习，如果回答不上来，对他们也有提醒作用，让他们感受到掌握不牢固，需要回顾今天所学内容。 ","date":"2022-05-28","objectID":"/learnmethods/:3:4","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"有个性的学生：另起炉灶 对于有的学生，喜欢看书不喜欢做题，问起原因：书读百遍，其义自见。他们认为，对于错题，他们是没有很好的掌握课本，所以要先把课本内容掌握，然后再做题。这一类学生，往往是比较聪明的，他们能够找自己的错因，然后去行动去改正，但是却片面的认为错因一定都在书本：书本吃透，做题无忧。其实，看书和做题是相辅相成的，就像是认识与实践，再认识再实践，循环往复，无限上升。对于这一类学生，做题认识有一些走偏了的，很难说服，因为他们觉得自己的相关是对的，而且这种感觉很真实，不会过多关注他人善意的提醒。因此，要时常点拨，不断引起他们注意，同时也要注意方式方法，毕竟处在青春期，有一些逆反心理。 当然，学生自身上课有犯困的，有不学习的，心不在焉的，各式各类都有，因此能够安心在学习之路探索的，精力大部分时间在学习上的，并不是全部学生，要认识到这一客观的差异性。学生老好犯困，屡次叫不醒，不如干脆让她睡一会，“充充电”，再好好学。 ","date":"2022-05-28","objectID":"/learnmethods/:3:5","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["学习方法"],"content":"管理学生与学生关系，把握严与宽的辩证关系 要处理好一对辩证关系，不能管的太严，凡事上纲上线，会让学生和老师很难堪，同时也不能管的很松，因为某些地方最好不要指望未成年人的自律能力，何况有时成年人也会有。在不同时间地点，严格与宽松中把握，方能管理好学生和与其建立良好关系。 在一些地方，如果感觉自己很难做到，那么就不要要求学生也要做到。譬如晚上要背好几页内容，自己不一定完成，所以也不要逼迫学生完成。但是，如果一些不费脑力的工作，自己能够完成，学生完不成，很可能是学生不用功，这个时候要从严。 对于上课手机问题，首先是自己做到不带手机进教室，然后才能要求学生这样做。其次，对于看到学生使用手机，要一视同仁去处理。很多时候，学生带着手机上自习，玩心自启。所以这时候要全面禁止手机，在来到时要提醒交手机，当然有的学生也会说交了或者没带，在自习过程中，一旦发现，“缴获”也可以，帮助上缴。 无论上课还是自习，睡觉瞌睡总是一种不良的习惯，但是如果学生睡觉屡次提醒还是不起作用，不如让其睡一会，充充电，才更用精力学习，所谓物极必反，大概就是这个意思。这个时候，纪律要从宽。 学习更多时候是一件放松下来，投入思考的事情，或者说是一件自己主动的事情，所以很多时候，管理应该从宽，而不是让学生时刻有着纪律意识。换句话说，如果管理者一直强调纪律，那么很明显，学生心思已经不在学习上面了。因此，宽与严的关系，以宽为主，管理严格是为了将来的宽，培养学生自律意识。 ","date":"2022-05-28","objectID":"/learnmethods/:3:6","tags":["学习方法","教育"],"title":"学习过程，矛盾的转移","uri":"/learnmethods/"},{"categories":["机器学习"],"content":"介绍 混淆矩阵、精度和召回率、F1值、ROC曲线 ","date":"2022-05-27","objectID":"/classificationperformancemeasures/:0:0","tags":["ROC曲线","混淆矩阵","召回率","精度","F1分数"],"title":"二元分类器性能的衡量","uri":"/classificationperformancemeasures/"},{"categories":["机器学习"],"content":"首先建立一个分类模型 import pandas as pd import sklearn import numpy as np np.random.seed(42) # 保持统一的随机数 data_X=pd.read_csv(\"900samples0519count.csv\") data_Y=pd.read_csv(\"Sample_info0519count.csv\") X_all=data_X.drop([\"Unnamed: 0\"],axis=1) data_Y.Group[data_Y[\"Group\"]==\"T2DM\"]=1 # 2型糖尿病 data_Y.Group[data_Y[\"Group\"]==\"NGT\"]=0 Y_all=data_Y.drop([\"Sample\",\"Dataset\"],axis=1) # 随机打乱 data_size = Y_all.shape[0] # 数据集个数 arr = np.arange(data_size) # 生成0到datasize个数 np.random.shuffle(arr) # 随机打乱arr数组 X_allRd = X_all.values[arr] # 将data以arr索引重新组合 Y_allRd = Y_all.values[arr] # 将label以arr索引重新组合 Y_allRd = Y_allRd.ravel() # Y_allRd 展平 # 划分数据集 X_train, X_test, y_train, y_test = X_allRd[:700], X_allRd[700:], Y_allRd[:700], Y_allRd[700:] # 对标签设置 True 和 False y_train_1 = (y_train == 1) y_test_1 = (y_test == 1) # 使用随机梯度进行分类 from sklearn.linear_model import SGDClassifier sgd_clf = SGDClassifier(max_iter=1000, tol=1e-3, random_state=42) sgd_clf.fit(X_train, y_train_1) # 使用交叉验证测量准确率 from sklearn.model_selection import cross_val_score cross_val_score(sgd_clf, X_train, y_train_1, cv=3, scoring=\"accuracy\") # 输出：array([0.63247863, 0.48497854, 0.4806867 ]) 这里我们看到 3折交叉验证的测试集准确率最好的为0.6。 下面我们实现一个分类器，将预测的数据全部“蒙”错，然后查看准确率。 from sklearn.base import BaseEstimator class Never1Classifier(BaseEstimator): def fit(self, X, y=None): pass def predict(self, X): return np.zeros((len(X), 1), dtype=bool) never_1_clf = Never1Classifier() cross_val_score(never_1_clf, X_train, y_train_1, cv=3, scoring=\"accuracy\") # 输出：array([0.68376068, 0.64377682, 0.63519313]) 居然我们自己实现的全蒙错的分类器比训练的分类器还好，是不是意味着有可能 训练的分类器在蒙。不能通过准确率，我们如何证实他确实是蒙的？通过混淆矩阵 ","date":"2022-05-27","objectID":"/classificationperformancemeasures/:1:0","tags":["ROC曲线","混淆矩阵","召回率","精度","F1分数"],"title":"二元分类器性能的衡量","uri":"/classificationperformancemeasures/"},{"categories":["机器学习"],"content":"混淆矩阵 如果识别一个数字是不是5，可能有以下四种情况。如下图所示，纵坐标actual表示实际情况，横坐标predicted表示预测情况。 真阳性（TP）预测对了，预测是真（阳） 假阳性（FP）预测错了，预测结果为真（阳） 真阴性（TN）预测对了，预测为假（阴） 假阴性（FN）预测错了，预测为阴 对于上面字母的记忆，前两个字母T、F表示 预测的对不对，其中T（True）是预测对，F（False）是预测错。后两个字母P、N，表示预测的结果，P（Positive）表示预测的为阳性，注意这是预测的结果，实际可不一定为真的。N（Negative）预测为阴性。这样FN，就是表示：被错误的预测为假的，换句话说其实是真的。 下面是混淆矩阵图 我们看一下全蒙错的分类器混淆矩阵，数组的数字表示预测数据的个数。可以看到，无论实际是真的还是假的，都被预测为阴，而预测为阳性的个数是0个。这样我们可以百分百确定，这是蒙的。 from sklearn.model_selection import cross_val_predict from sklearn.metrics import confusion_matrix y_train_pred = cross_val_predict(never_1_clf, X_train, y_train_1, cv=3) confusion_matrix(y_train_1, y_train_pred) # array([[458, 0], # [242, 0]]) 看一下训练的分类器混淆矩阵，可以看见分类器确实在努力的去分类了，尽管准确率不如蒙的。 y_train_pred = cross_val_predict(sgd_clf, X_train, y_train_1, cv=3) confusion_matrix(y_train_1, y_train_pred) # array([[224, 234], # [ 93, 149]]) ","date":"2022-05-27","objectID":"/classificationperformancemeasures/:2:0","tags":["ROC曲线","混淆矩阵","召回率","精度","F1分数"],"title":"二元分类器性能的衡量","uri":"/classificationperformancemeasures/"},{"categories":["机器学习"],"content":"精度和召回率 精度是衡量预测一个正样本，我能够有多少把握相信你。具体定义如下： $精度=\\frac{TP}{TP+FP}$ 精度越高，意味着预测越准，但是却不能保证实际为真的数据都被预测到。比如10个实际为真的样本，但只预测到了1个（TP=1），而且所有的预测的阳性样本，就只有这一个预测为阳性的。这样精度也不能很全面衡量分类器的效果。这里我们结合使用召回率来完善上面的不足。 召回率是衡量能否把所有为实际为真的样本都预测到，虽然可能包含实际为假的预测为阳性了，但是实际为真的都被找到是一件很成功的事情。比如，医院检查是否患病，如果召回率为99%那么绝大多数的病人都能被检测到，不至于患病却没有被及时发现从而贻误病情。当然这里没有患病的也有可能被检测为阳性，这里我们可以对检测为阳性，进行二次检测，换句话说召回他们来作复查。这也就是 召回率，具体定义： $召回率=\\frac{TP}{TP+FN}$ 如果增加检测的敏感性，可能 很多未患病的也被检测为阳性，那么意味着 FP值增加，精度减小，FN减小，则召回率增加。下图是该示意图，如果增加敏感性，降低阈值，让更多数据纳入，则召回率会增加，而精度会降低。 from sklearn.metrics import precision_score, recall_score # 精度（准确率） precision_score(y_train_1, y_train_pred) # 0.38903394255874674 # 召回率 recall_score(y_train_1, y_train_pred) # 0.6157024793388429 可以看到不同的阈值，会对应不同的精度和召回率，这样可以画一个图形，这就是 精度/召回率（PR）曲线 y_scores = cross_val_predict(sgd_clf, X_train, y_train_1, cv=3, method=\"decision_function\") from sklearn.metrics import precision_recall_curve precisions, recalls, thresholds = precision_recall_curve(y_train_1, y_scores) def plot_precision_recall_vs_threshold(precisions, recalls, thresholds): plt.plot(thresholds, precisions[:-1], \"b--\", label=\"Precision\", linewidth=2) plt.plot(thresholds, recalls[:-1], \"g-\", label=\"Recall\", linewidth=2) plt.legend(loc=\"lower right\", fontsize=16) # Not shown in the book plt.xlabel(\"Threshold\", fontsize=16) # Not shown plt.grid(True) # Not shown plt.axis([-9.93552427e+13, 1.59360987e+14, 0, 1]) # Not shown plot_precision_recall_vs_threshold(precisions, recalls, thresholds) plt.show() ","date":"2022-05-27","objectID":"/classificationperformancemeasures/:3:0","tags":["ROC曲线","混淆矩阵","召回率","精度","F1分数"],"title":"二元分类器性能的衡量","uri":"/classificationperformancemeasures/"},{"categories":["机器学习"],"content":"精度/召回率权衡 F1值，让上面两个衡量指标变成一个，便于判断分类器性能 from sklearn.metrics import f1_score # 我们可以很方便地将精度和召回率组合成一个单一的指标，称 为F 1 分数。 f1_score(y_train_1, y_train_pred) # 0.4768 ","date":"2022-05-27","objectID":"/classificationperformancemeasures/:4:0","tags":["ROC曲线","混淆矩阵","召回率","精度","F1分数"],"title":"二元分类器性能的衡量","uri":"/classificationperformancemeasures/"},{"categories":["机器学习"],"content":"ROC 曲线 ROC 与精度/召回率曲线非常相似，但绘制的不是精度 和召回率，而是真正类率（召回率的另一名称）和假正类率（FPR）。 y_scores = cross_val_predict(sgd_clf, X_test, y_test_1, cv=3, method=\"decision_function\") from sklearn.metrics import roc_curve fpr, tpr, thresholds = roc_curve(y_test_1, y_scores) def plot_roc_curve(fpr, tpr, label=None): plt.plot(fpr, tpr, linewidth=2, label=label) plt.plot([0, 1], [0, 1], 'k--') # dashed diagonal plt.axis([0, 1, 0, 1]) # Not shown in the book plt.xlabel('False Positive Rate (Fall-Out)', fontsize=16) # Not shown plt.ylabel('True Positive Rate (Recall)', fontsize=16) # Not shown plt.grid(True) plt.figure(figsize=(8, 6)) plot_roc_curve(fpr, tpr,\"SGDClassifier\") plt.legend(loc=\"lower right\", fontsize=16) plt.show() ROC曲线图形越向左上角意味着分类器分类效果越好，下面实现一个随机森林分类器，比较两个分类器，可见随机森林要比随机梯度分类器分类效果一些。 from sklearn.ensemble import RandomForestClassifier rfc1 = RandomForestClassifier(n_estimators=500, max_leaf_nodes=16, random_state=42) rfc1.fit(X_train, y_train_1) pre_y = rfc1.predict_proba(X_test)[:, 1] fpr_Nb, tpr_Nb, _ = roc_curve(y_test_1, pre_y) plt.figure(figsize=(8, 6)) plot_roc_curve(fpr, tpr,\"SGDClassifier\") plot_roc_curve(fpr_Nb, tpr_Nb,\"RandomForestClassifier\") plt.legend(loc=\"lower right\", fontsize=16) plt.show() ","date":"2022-05-27","objectID":"/classificationperformancemeasures/:5:0","tags":["ROC曲线","混淆矩阵","召回率","精度","F1分数"],"title":"二元分类器性能的衡量","uri":"/classificationperformancemeasures/"},{"categories":["机器学习"],"content":"一个简单的线性回归例子 下面，我们将梯度下降解决一个线性回归问题。 首先，定义数据、查看数据和进行归一化操作 import numpy as np import matplotlib.pyplot as plt X_raw = np.array([2013, 2014, 2015, 2016, 2017]) y_raw = np.array([12000, 14000, 15000, 16500, 17500]) X = (X_raw - X_raw.min()) / (X_raw.max() - X_raw.min()) y = (y_raw - y_raw.min()) / (y_raw.max() - y_raw.min()) # 查看数据 plt.scatter(X_raw,y_raw) plt.xlabel('year') plt.ylabel('price') plt.xlim((2012, 2018)) plt.show() 设假设函数为 $y=ax+b$ 损失函数为均方差 $\\min_{a,b}L(a,b)=\\frac{1}{2}\\Sigma_{i=1}^{5}=(ax_i+b-y)^2$ 偏导数 $\\frac{\\partial L}{\\partial a}=\\Sigma_{i=1}^{5}=(ax_i+b-y)x_i$ $\\frac{\\partial b}{\\partial a}=\\Sigma_{i=1}^{5}=(ax_i+b-y)$ # 对应梯度计算 Python代码 y_pred = a * X + b grad_a, grad_b = (y_pred - y).dot(X), (y_pred - y).sum() 完整的梯度计算代码 a, b = 0, 0 num_epoch = 10000 learning_rate = 1e-3 for e in range(num_epoch): # 手动计算损失函数关于自变量（模型参数）的梯度 y_pred = a * X + b grad_a, grad_b = (y_pred - y).dot(X), (y_pred - y).sum() # 更新参数 a, b = a - learning_rate * grad_a, b - learning_rate * grad_b print(a, b) # 0.9763702087567374 0.05756498076575413 显示归一化后的函数和点集 x_p=np.arange(0.0,1.1,0.1) y_p=a*x_p+b plt.plot(x_p,y_p,label=\"predict\") plt.scatter(X,y,c='red') plt.show() 反归一化，对应到实际问题，将归一化的方式逆运算即可 def scal(x): return (x-X_raw.min())/(X_raw.max()-X_raw.min()) def inv(y): return y*(y_raw.max()-y_raw.min())+y_raw.min() x_f=np.arange(2010,2020,1) f_x=inv(a*scal(x_f)+b) plt.plot(x_f,f_x) plt.scatter(X_raw,y_raw) plt.xlabel('year') plt.ylabel('price') plt.show() ","date":"2022-05-17","objectID":"/linermodel/:0:1","tags":["线性回归","梯度下降","numpy"],"title":"一个简单的线性回归例子","uri":"/linermodel/"},{"categories":["机器学习"],"content":"使用esp32cam+micropython 控制小车","date":"2022-05-17","objectID":"/esp32cam%E5%B0%8F%E8%BD%A6%E4%BB%A3%E7%A0%81/","tags":["esp32cam","micropython"],"title":"使用esp32cam和micropython控制小车","uri":"/esp32cam%E5%B0%8F%E8%BD%A6%E4%BB%A3%E7%A0%81/"},{"categories":["机器学习"],"content":"功能描述 手机搜索WIFI，加入camera_1，密码，浏览器访问一下链接 192.168.4.1 查看实时拍照 192.168.4.1/left 控制左转 192.168.4.1/right 控制右转 192.168.4.1/forward 控制直行 单次运动时长为moveTime=0.05s，直行大约1.5cm。 ","date":"2022-05-17","objectID":"/esp32cam%E5%B0%8F%E8%BD%A6%E4%BB%A3%E7%A0%81/:0:1","tags":["esp32cam","micropython"],"title":"使用esp32cam和micropython控制小车","uri":"/esp32cam%E5%B0%8F%E8%BD%A6%E4%BB%A3%E7%A0%81/"},{"categories":["机器学习"],"content":"代码 import picoweb import ulogging as logging import gc import ujson import network import camera import time from machine import Pin from machine import PWM p4 = Pin(2, Pin.OUT) r14=Pin(14, Pin.OUT) # pwm0 = PWM(Pin(2)) # freq = pwm0.freq() moveTime=0.05 swq={\"set_password\":\"12345678\",\"set_wifi\":\"camera_1\",\"wifi\":\"12345678\",\"password\":\"\",\"pixel\":\"6\"} conf=swq import network ap= network.WLAN(network.AP_IF) ap.active(True) ap.config(essid=conf['set_wifi'], authmode=network.AUTH_WPA_WPA2_PSK, password=conf['set_password']) # sta_if = network.WLAN(network.STA_IF) # sta_if.active(True) # sta_if.connect('CMCC-A168','xg168168') time.sleep(5) # print(sta_if.ifconfig()) print(ap.ifconfig()) # 开机自检 p4.on() r14.on() time.sleep(1) p4.off() r14.off() try: camera.init(0, format=camera.JPEG) except Exception as e: camera.deinit() camera.init(0, format=camera.JPEG) camera.framesize(camera.FRAME_QVGA) # if conf['pixel'] =='1': # camera.framesize(camera.FRAME_QQVGA) # elif conf['pixel'] =='2': # camera.framesize(camera.FRAME_240X240) # elif conf['pixel'] =='3': # camera.framesize(camera.FRAME_QVGA) # elif conf['pixel'] =='4': # camera.framesize(camera.FRAME_VGA) # elif conf['pixel'] =='5': # camera.framesize(camera.FRAME_SVGA) # elif conf['pixel']=='6': # camera.framesize(camera.FRAME_HD) # else: # camera.framesize(camera.FRAME_240X240) app = picoweb.WebApp(__name__) def rdImage(): q=camera.capture() # return b'Content-Type: image/jpg\\n'+q return q @app.route(\"/left\") def led_on(req,resp): yield from picoweb.start_response(resp) p4.value(1) time.sleep(moveTime) p4.value(0) # pwm0.freq(10) q='left' yield from resp.awrite(q) gc.collect() @app.route(\"/right\") def led_on(req,resp): yield from picoweb.start_response(resp) r14.value(1) time.sleep(moveTime) r14.value(0) #pwm0.freq(1000) q='right' yield from resp.awrite(q) gc.collect() @app.route(\"/forward\") def led_on(req,resp): yield from picoweb.start_response(resp) p4.value(1) r14.value(1) time.sleep(moveTime) p4.value(0) r14.value(0) #pwm0.freq(1000) q='forward' yield from resp.awrite(q) gc.collect() @app.route(\"/\") def getImg(req,resp): yield from picoweb.start_response(resp,content_type = \"image/jpeg\") yield from resp.awrite(rdImage()) gc.collect() logging.basicConfig(level=logging.INFO) app.run(debug=False,host='0.0.0.0',port=\"80\") 代码写入 使用thonny，下载线连接esp32cam1 接线参考 参考B站2 不足之处（改进方向） 代码和处理器： 性能有限：esp32cam 计算性能有限，micropython 相对于C++运行性能也低，因此 不能实时传输视频流和使用pwm方式调节电机。否则 查看视频流esp32cam会卡顿，pwm调节无反应 小车： 小车前轮抓地力不足：小车为后驱车，电池重心靠后，在前面增加了9v电池增重。不过，应该买一个四驱的，平衡性高 ","date":"2022-05-17","objectID":"/esp32cam%E5%B0%8F%E8%BD%A6%E4%BB%A3%E7%A0%81/:0:2","tags":["esp32cam","micropython"],"title":"使用esp32cam和micropython控制小车","uri":"/esp32cam%E5%B0%8F%E8%BD%A6%E4%BB%A3%E7%A0%81/"},{"categories":["机器学习"],"content":"参考 esp32cam 写入 micropython固件、thonny编程、pip安装模块 https://zenanlin1999.github.io/2021/07/26/ESP%E5%BC%80%E5%8F%911%E2%80%94%E2%80%94%E4%B8%8A%E6%89%8BESP32-CAM%E4%B8%A4%E7%A7%8D%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F/ ↩︎ B站 C++实现实时视频流控制小车 https://www.bilibili.com/video/BV1qu41117JP ↩︎ ","date":"2022-05-17","objectID":"/esp32cam%E5%B0%8F%E8%BD%A6%E4%BB%A3%E7%A0%81/:0:3","tags":["esp32cam","micropython"],"title":"使用esp32cam和micropython控制小车","uri":"/esp32cam%E5%B0%8F%E8%BD%A6%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":"下面，我们将梯度下降解决一个线性回归问题。 关键词：numpy、梯度、归一化 PS：如果不清楚关键词内容，请自学关键词相关内容再阅读 首先，定义数据和进行归一化操作 import numpy as np X_raw = np.array([2013, 2014, 2015, 2016, 2017]) y_raw = np.array([12000, 14000, 15000, 16500, 17500]) #归一化 X=(X_raw-X_raw.min())/(X_raw.max()-X_raw.min()) y=(y_raw-y_raw.min())/(y_raw.max()-y_raw.min()) ","date":"2022-05-15","objectID":"/post/my-first-post/:0:0","tags":null,"title":"线性回归","uri":"/post/my-first-post/"}]